# **Algoritmos e Programação Estruturada**
> Operações e expressões

Nesta webaula temos como objetivo apresentar os operadores matemáticos, relacionais e lógicos. 

<img align="right" alt="image_01" src="https://github.com/roneycsilva/Algoritmos_Programa-o_Estruturada/assets/61150519/d81d3104-3961-4cf0-9f48-a267ccd5b095" width="310" height="250">       

  <div style=" height: 300px; margin: 15px; position: relative; display: block;" >
   <p style="word-wrap: break-word; " 

>**Sistemas computacionais**

Desde o momento em que você liga um computador (ou tablet, ou smartphone), centenas de processos são inicializados e passam a competir pelo processador para que possam ser executados e fazer a “mágica” do mundo digital acontecer. 

Todos os resultados desses sistemas são obtidos através do processamento de dados e nesta webaula começaremos a estudar os recursos que lhe permitirão implementar soluções com processamento.
Os sistemas computacionais são construídos para resolver os mais diversos problemas. Todos esses sistemas, independentemente da sua aplicação, são construídos em três partes: entrada, processamento e saída.

Nos três casos, a leitura dos dados é feita para um único fim: processamento e geração de informações e essa etapa é construída a partir da combinação de operações aritméticas, relacionais, lógicas e outras técnicas de programação.







&nbsp;</p>

>**Operadores aritméticos**

<img align="right" alt="image_01" src="https://github.com/roneycsilva/Algoritmos_Programa-o_Estruturada/assets/61150519/d81d3104-3961-4cf0-9f48-a267ccd5b095" width="310" height="250">       

  <div style=" height: 300px; margin: 15px; position: relative; display: block;" >
   <p style="word-wrap: break-word; " 

>**Operadores aritméticos **

Vamos começar a aprimorar nossos algoritmos através das operações aritméticas. Os operadores aritméticos podem ser classificados em unários ou binários (MANZANO, 2015)







&nbsp;</p>

Na época, recursos de memória eram caros e limitados – por exemplo, 1 MB de memória custava em torno de 700 dólares. Por isso, havia uma constante necessidade, por parte dos desenvolvedores, de economizar e otimizar espaço em memória. 
Assim, na década de 1960 as datas eram armazenadas, porém, eram interpretados apenas dois dígitos para o ano – os dois últimos dígitos.

No caso, o ano de 1999 seria interpretado apenas como “99” (dois últimos dígitos). Com isso, o receio era que, em vez de os sistemas reconhecerem o ano de 2000, o identificassem como ano de 1900, zerando os dois últimos dígitos na data. 

De fato, o problema não causou tantos impactos, pois muitos sistemas desenvolvidos na época já consideravam o ano com quatro dígitos. Porém, problemas pontuais ocorreram; alguns sites da época não reconheciam a data e mostravam a data “01/01/19100”, e houve falhas em terminais de ônibus e equipamentos de medição de radiação. 
Houve, também, investimentos de bilhões de dólares em medidas preventivas. 

Caso realmente tivesse se concretizado, esse acontecimento causaria um enorme prejuízo para bancos, com juros negativos, investidores e empresas poderiam indo à falência. 
Os sistemas de aeroportos e usinas nucleares poderiam entrar em colapso, causando quedas de aviões e vazamentos radioativos. 
Atualmente é improvável que esse tipo de problema ocorra, pois já temos alternativas de armazenamento em nuvem e recursos de memória mais baratos. 

>**VAMOS PRATICAR!**

Para exercitar um pouco, observe o código com o erro que se assemelha ao ocorrido no caso do foguete Ariane 5. Mostra que os erros de execução (run time error) são comuns quando se declara um vetor ou array com menor capacidade que o necessário para o problema. Nesse caso, o código é compilado sem erros, porém ocorrem problemas na execução. 

Para realizar um teste prático, utilize a ferramenta [Online GDB](https://www.onlinegdb.com/), um compilador online em C. 

Clique no botão Run para executar o código e observe possíveis runtime errors.
